package nz.bradcampbell.paperparcel.kotlinexample

import android.os.Parcel
import android.os.Parcelable
import com.google.common.truth.Truth.assertThat
import nz.bradcampbell.paperparcel.PaperParcels
import nz.bradcampbell.paperparcel.TypedParcelable
import org.junit.Test
import java.util.*

class PaperParcelsKotlinTest {
  @Test
  fun wrapToConcreteType() {
    val originalObj = State(1, Date())
    val stateParcel: StateParcel = PaperParcels.wrap(originalObj)
    val unwrapped = PaperParcels.unwrap(stateParcel)
    assertThat(originalObj).isEqualTo(unwrapped)

    val unsafeUnwrapped = PaperParcels.unsafeUnwrap<State>(stateParcel)
    assertThat(originalObj).isEqualTo(unsafeUnwrapped)
  }

  @Test
  fun wrapToGenericType() {
    val originalObj = State(1, Date())
    val stateParcel: TypedParcelable<State> = PaperParcels.wrap(originalObj)
    val unwrapped = PaperParcels.unwrap(stateParcel)
    assertThat(originalObj).isEqualTo(unwrapped)

    val unsafeUnwrapped = PaperParcels.unsafeUnwrap<State>(stateParcel)
    assertThat(originalObj).isEqualTo(unsafeUnwrapped)
  }

  @Test
  fun wrapToRawParcelable() {
    val originalObj = State(1, Date())
    val stateParcel: Parcelable = PaperParcels.wrap(originalObj)
    @Suppress("UNCHECKED_CAST")
    val unwrapped = PaperParcels.unwrap(stateParcel as TypedParcelable<State>)
    assertThat(originalObj).isEqualTo(unwrapped)

    val unsafeUnwrapped = PaperParcels.unsafeUnwrap<State>(stateParcel)
    assertThat(originalObj).isEqualTo(unsafeUnwrapped)
  }

  @Test
  fun wrapUnparcelableType() {
    try {
      PaperParcels.wrap("foo")
    } catch (e: Throwable) {
      assertThat(e).hasMessage(
          "Unable to find PaperParcel for type 'String', did you forget to annotate it with @PaperParcel?")
    }

  }

  @Test
  fun unwrapNonPaperParcelableType() {
    try {
      PaperParcels.unsafeUnwrap<Any>(NonPaperParcelable("taco"))
    } catch (e: Throwable) {
      assertThat(e).hasMessage(
          "Unable to cast 'NonPaperParcelable' to TypedParcelable, are you sure this Parcelable was generated by @PaperParcel?")
    }

  }

  @Test
  fun unwrapNonGeneratedTypedParcelable() {
    try {
      PaperParcels.unwrap(NonGeneratedTypedParcelable(Taco("taco")))
    } catch (e: Throwable) {
      assertThat(e).hasMessage(
          "Unable to find PaperParcel for parcel type 'NonGeneratedTypedParcelable'...did you manually implement TypedParcelable instead of using @PaperParcel?")
    }

  }

  private class NonGeneratedTypedParcelable(private val taco: Taco) : TypedParcelable<Taco> {
    override fun describeContents(): Int {
      return 0
    }

    override fun writeToParcel(dest: Parcel, flags: Int) {
      dest.writeString(taco.taco)
    }

    companion object {
      val CREATOR: Parcelable.Creator<Taco> = object : Parcelable.Creator<Taco> {
        override fun createFromParcel(parcel: Parcel): Taco {
          return Taco(parcel)
        }

        override fun newArray(size: Int): Array<Taco?> {
          return arrayOfNulls(size)
        }
      }
    }
  }

  private class Taco {
    val taco: String

    constructor(taco: String) {
      this.taco = taco
    }

    constructor(parcel: Parcel) {
      taco = parcel.readString()
    }
  }

  private class NonPaperParcelable : Parcelable {


    private val taco: String

    constructor(taco: String) {
      this.taco = taco
    }

    private constructor(parcel: Parcel) {
      taco = parcel.readString()
    }

    override fun describeContents(): Int {
      return 0
    }

    override fun writeToParcel(dest: Parcel, flags: Int) {
      dest.writeString(taco)
    }

    companion object {
      val CREATOR: Parcelable.Creator<NonPaperParcelable> = object : Parcelable.Creator<NonPaperParcelable> {
        override fun createFromParcel(parcel: Parcel): NonPaperParcelable {
          return NonPaperParcelable(parcel)
        }

        override fun newArray(size: Int): Array<NonPaperParcelable?> {
          return arrayOfNulls(size)
        }
      }
    }
  }
}
