package nz.bradcampbell.paperparcel;

import android.os.Parcelable;
import java.lang.reflect.Field;
import java.util.Map;

/**
 * Central mechanism for {@link #wrap(Object)}ing/{@link #unwrap(TypedParcelable)}ping arbitrary
 * PaperParcel objects.
 */
public final class PaperParcels {
  static final Map<Class, Delegator> FROM_ORIGINAL;
  static final Map<Class, Delegator> FROM_PARCELABLE;

  static {
    //noinspection TryWithIdenticalCatches
    try {
      Class clazz = Class.forName("nz.bradcampbell.paperparcel.PaperParcelMapping");
      FROM_ORIGINAL = getFieldValue(clazz, "FROM_ORIGINAL");
      FROM_PARCELABLE = getFieldValue(clazz, "FROM_PARCELABLE");
    } catch (ClassNotFoundException e) {
      throw new RuntimeException(e);
    } catch (NoSuchFieldException e) {
      throw new RuntimeException(e);
    } catch (IllegalAccessException e) {
      throw new RuntimeException(e);
    }
  }

  /**
   * Wrap the specified object in its PaperParcel wrapper.
   * @throws IllegalArgumentException if wrapper is not found (no @PaperParcel annotation on type).
   */
  public static <T, TP extends TypedParcelable<T>> TP wrap(T originalObj) {
    if (originalObj == null) {
      return null;
    }
    Class<?> type = originalObj.getClass();
    //noinspection unchecked
    Delegator<T, TypedParcelable<T>> delegator = FROM_ORIGINAL.get(type);
    if (delegator == null) {
      throw new IllegalArgumentException("Unable to find PaperParcel for type '" + type.getSimpleName() + "', did you forget to annotate it with @PaperParcel?");
    }
    //noinspection unchecked
    return (TP) delegator.wrap(originalObj);
  }

  /**
   * Unwrap the specified Parcelable to its original @PaperParcel'd object.
   * @throws IllegalArgumentException if the provided TypedParcelable was not generated by @PaperParcel.
   */
  public static <T> T unwrap(TypedParcelable<T> parcelableObj) {
    if (parcelableObj == null) {
      return null;
    }
    Class<?> type = parcelableObj.getClass();
    //noinspection unchecked
    Delegator<T, TypedParcelable<T>> delegator = FROM_PARCELABLE.get(type);
    if (delegator == null) {
      throw new IllegalArgumentException("Unable to find PaperParcel for parcel type '" + type.getSimpleName() + "'...did you manually implement TypedParcelable instead of using @PaperParcel?");
    }
    return delegator.unwrap(parcelableObj);
  }

  /**
   * Unwrap the specified Parcelable to its original @PaperParcel'd object.
   * @throws IllegalArgumentException if there is not a wrapper (no @PaperParcel annotation on original type).
   */
  public static <T> T unsafeUnwrap(Parcelable parcelableObj) {
    TypedParcelable<T> unsafeCast;
    try {
      //noinspection unchecked
      unsafeCast = (TypedParcelable<T>) parcelableObj;
    } catch (ClassCastException e) {
      throw new IllegalArgumentException("Unable to cast '" + parcelableObj.getClass().getSimpleName() + "' to TypedParcelable, are you sure this Parcelable was generated by @PaperParcel?");
    }
    return unwrap(unsafeCast);
  }

  /**
   * Creates an array of the original type
   * @param type The class of the original type
   * @param i The size of the array
   * @param <T> The original type
   * @return A new array of size i
   */
  public static <T> T[] newArray(Class<? extends T> type, int i) {
    //noinspection unchecked
    Delegator<T, TypedParcelable<T>> delegator = FROM_ORIGINAL.get(type);
    if (delegator == null) {
      return null;
    }
    return delegator.newArray(i);
  }

  interface Delegator<ORIG, PARCEL extends TypedParcelable<ORIG>> {
    ORIG unwrap(PARCEL parcelableObj);

    TypedParcelable<ORIG> wrap(ORIG originalObj);

    ORIG[] newArray(int i);
  }

  private static Map<Class, Delegator> getFieldValue(Class clazz, String fieldName)
      throws NoSuchFieldException, IllegalAccessException {
    Field field = clazz.getDeclaredField(fieldName);
    field.setAccessible(true);
    //noinspection unchecked
    return (Map<Class, Delegator>) field.get(null);
  }
}
